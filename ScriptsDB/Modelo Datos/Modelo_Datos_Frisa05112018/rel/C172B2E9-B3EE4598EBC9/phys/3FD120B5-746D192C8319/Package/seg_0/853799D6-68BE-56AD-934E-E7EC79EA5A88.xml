<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="XXFR_INGRESOS_LC" directorySegmentName="seg_0" id="853799D6-68BE-56AD-934E-E7EC79EA5A88">
<sourceConnName>Frisa_Dev</sourceConnName>
<sourceObjSchema>INGRESOS</sourceObjSchema>
<sourceObjName>XXFR_INGRESOS_LC</sourceObjName>
<createdBy>USER_1</createdBy>
<createdTime>2018-11-28 17:36:28 UTC</createdTime>
<ownerDesignName>Modelo_Datos_Frisa05112018</ownerDesignName>
<owner>B49CDF25-C9F3-EDEF-C941-F4C9279E8404</owner>
<source>CREATE OR REPLACE PACKAGE INGRESOS.XXFR_INGRESOS_LC AS /**/&lt;br/&gt;    FUNCTION xxfr_ingresos_cuenta_facturas (&lt;br/&gt;        entrada IN   VARCHAR2&lt;br/&gt;    ) RETURN NUMBER;&lt;br/&gt;&lt;br/&gt;    FUNCTION xxfr_ingresos_recupera_fac (&lt;br/&gt;        entrada IN   VARCHAR2&lt;br/&gt;    ) RETURN xxfr_factura_table;&lt;br/&gt;&lt;br/&gt;    FUNCTION xxfr_generarlc (&lt;br/&gt;        division           IN                 VARCHAR2,&lt;br/&gt;        proyecto           IN                 NUMBER,&lt;br/&gt;        contrato           IN                 NUMBER,&lt;br/&gt;        lineacapturain     IN                 VARCHAR2,&lt;br/&gt;        nombrebanco        IN                 VARCHAR2,&lt;br/&gt;        fechatransaccion   IN                 VARCHAR2,&lt;br/&gt;        totalFactuado   IN                 VARCHAR2,&lt;br/&gt;      referencia    IN VARCHAR2 &lt;br/&gt;    ) RETURN VARCHAR2;&lt;br/&gt;&lt;br/&gt;    FUNCTION xxfr_procesar_batch (&lt;br/&gt;        idParBatch VARCHAR2&lt;br/&gt;    ) RETURN VARCHAR2;&lt;br/&gt;&lt;br/&gt;    FUNCTION xxfr_id_lc (&lt;br/&gt;        val1 NUMBER&lt;br/&gt;    ) RETURN VARCHAR2;&lt;br/&gt;&lt;br/&gt;    FUNCTION xxfr_digitoverificador (&lt;br/&gt;        nombrebanco   IN            VARCHAR2,&lt;br/&gt;        fechabase     IN            VARCHAR2,&lt;br/&gt;        constante IN VARCHAR2,&lt;br/&gt;        totalFactuado IN VARCHAR2,&lt;br/&gt;        referencia IN VARCHAR2&lt;br/&gt;    ) RETURN VARCHAR2;&lt;br/&gt;&lt;br/&gt;function numCondensado(numPocess IN number) return number;&lt;br/&gt;FUNCTION calculaImpoteCondensado(&lt;br/&gt;      totalFactuado IN VARCHAR2,&lt;br/&gt;      nombrebanco   IN VARCHAR2)&lt;br/&gt;    RETURN NUMBER;&lt;br/&gt;function totalLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2,&lt;br/&gt;   pProjectID  IN VARCHAR2) RETURN VARCHAR2;&lt;br/&gt;FUNCTION codeSumDV (referencia IN VARCHAR2) RETURN VARCHAR2;&lt;br/&gt;&lt;br/&gt;function fechaLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2,&lt;br/&gt;   pProjectID  IN VARCHAR2&lt;br/&gt;  ) RETURN VARCHAR2;&lt;br/&gt;  &lt;br/&gt;  function referenciaLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2,&lt;br/&gt;   pProjectID  IN VARCHAR2&lt;br/&gt;  ) RETURN VARCHAR2;&lt;br/&gt;&lt;br/&gt;function procesarLC_Vencidadas (pIdBatch IN VARCHAR2, contrato in VARCHAR2, grupo in VARCHAR2, division in VARCHAR2, proyecto in VARCHAR2) return varchar2;&lt;br/&gt;&lt;br/&gt;function proyectoIDLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2&lt;br/&gt;  ) RETURN VARCHAR2;&lt;br/&gt;&lt;br/&gt;END xxfr_ingresos_lc;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="XXFR_INGRESOS_LC" id="853799D6-68BE-56AD-934E-E7EC79EA5A88">
<sourceConnName>Frisa_Dev</sourceConnName>
<sourceObjSchema>INGRESOS</sourceObjSchema>
<sourceObjName>XXFR_INGRESOS_LC</sourceObjName>
<createdBy>USER_1</createdBy>
<createdTime>2018-11-28 17:36:34 UTC</createdTime>
<ownerDesignName>Modelo_Datos_Frisa05112018</ownerDesignName>
<owner>B49CDF25-C9F3-EDEF-C941-F4C9279E8404</owner>
<source>CREATE OR REPLACE PACKAGE BODY INGRESOS.XXFR_INGRESOS_LC&lt;br/&gt;AS&lt;br/&gt;  tot_fact xxfr_lc_table;&lt;br/&gt;  descNomBancoBBVA VARCHAR2(30) := &apos;BBVA Bancomer, S.A.&apos;;&lt;br/&gt;    descNomBancoBANORTE VARCHAR2(30) := &apos;BANORTE, S.A.&apos;;&lt;br/&gt;  --tot_depts XXFR_FACTURA_TABLE;&lt;br/&gt;  /*Función Contar Facturas*/&lt;br/&gt;  FUNCTION xxfr_ingresos_cuenta_facturas(&lt;br/&gt;      entrada IN VARCHAR2 )&lt;br/&gt;    RETURN NUMBER&lt;br/&gt;  AS&lt;br/&gt;    facturas NUMBER;&lt;br/&gt;  BEGIN&lt;br/&gt;    SELECT COUNT(*)&lt;br/&gt;    INTO facturas&lt;br/&gt;    FROM ingresos.xxfr_cabecera_factura&lt;br/&gt;    WHERE xxfr_cabecera_factura.idbatch = xxfr_ingresos_cuenta_facturas.entrada;&lt;br/&gt;    dbms_output.put_line(&apos;Facturas = &apos; || facturas);&lt;br/&gt;    RETURN facturas;&lt;br/&gt;  END xxfr_ingresos_cuenta_facturas;&lt;br/&gt;/*Función Recuperar Facturas*/&lt;br/&gt;  FUNCTION xxfr_ingresos_recupera_fac(&lt;br/&gt;      entrada IN VARCHAR2 )&lt;br/&gt;    RETURN xxfr_factura_table&lt;br/&gt;  IS&lt;br/&gt;    facturas xxfr_factura_table;&lt;br/&gt;  BEGIN&lt;br/&gt;    SELECT xxfr_factura_rec(idfacturaprimavera, contractnumber, grouptype) BULK COLLECT&lt;br/&gt;    INTO facturas&lt;br/&gt;    FROM ingresos.xxfr_cabecera_factura&lt;br/&gt;    WHERE xxfr_cabecera_factura.idbatch = xxfr_ingresos_recupera_fac.entrada&lt;br/&gt;    AND tipocobranza                    = &apos;LINEA CAPTURA&apos;&lt;br/&gt;    AND transactiontype                 = &apos;FAC_INGRESOS_MN&apos;;&lt;br/&gt;    RETURN facturas;&lt;br/&gt;  END xxfr_ingresos_recupera_fac;&lt;br/&gt;/*ID Código de Línea de Captura*/&lt;br/&gt;  FUNCTION xxfr_id_lc(&lt;br/&gt;      val1 NUMBER )&lt;br/&gt;    RETURN VARCHAR2&lt;br/&gt;  IS&lt;br/&gt;    idlc VARCHAR2(20);&lt;br/&gt;  BEGIN&lt;br/&gt;    SELECT lpad(ingresos.xxfr_ingresos_id_lc.nextval, 9, &apos;0&apos;) INTO idlc FROM dual;&lt;br/&gt;    RETURN idlc;&lt;br/&gt;  END xxfr_id_lc;&lt;br/&gt;/*ARMADO DE LC*/&lt;br/&gt;  FUNCTION xxfr_forma_lc(&lt;br/&gt;      idbatch IN VARCHAR2 )&lt;br/&gt;    RETURN xxfr_lc_table&lt;br/&gt;  IS&lt;br/&gt;    idlc xxfr_lc_table;&lt;br/&gt;  BEGIN&lt;br/&gt;    -------&lt;br/&gt;    SELECT xxfr_lc_rec(transactionsource, projectid, --Estos deberían ser 3 y no 4&lt;br/&gt;      contractnumber                                 --estos deberían ser 8, sólo tengo 3&lt;br/&gt;      ) BULK COLLECT&lt;br/&gt;    INTO tot_fact&lt;br/&gt;    FROM xxfr_cabecera_factura&lt;br/&gt;    WHERE idbatch = xxfr_forma_lc.idbatch;&lt;br/&gt;    -------SELECT COUNT(*) INTO idlc FROM XXFR_FORMA_LC.tot_fact;&lt;br/&gt;    /*RECUPERA ID DE LC  -- OK*/&lt;br/&gt;    /*ARMA LC*/&lt;br/&gt;    /*INSERTA LC*/&lt;br/&gt;    RETURN NULL;&lt;br/&gt;  END xxfr_forma_lc;&lt;br/&gt;--Fin--&lt;br/&gt;  FUNCTION xxfr_generarlc(&lt;br/&gt;      division         IN VARCHAR2,&lt;br/&gt;      proyecto         IN NUMBER,&lt;br/&gt;      contrato         IN NUMBER,&lt;br/&gt;      lineacapturain   IN VARCHAR2,&lt;br/&gt;      nombrebanco      IN VARCHAR2,&lt;br/&gt;      fechatransaccion IN VARCHAR2,&lt;br/&gt;      totalFactuado    IN VARCHAR2,&lt;br/&gt;      referencia    IN VARCHAR2 )&lt;br/&gt;      RETURN VARCHAR2&lt;br/&gt;  AS&lt;br/&gt;    lineacaptura         VARCHAR2(30) := &apos;&apos;;&lt;br/&gt;    errorparametro       VARCHAR2(30) := &apos;&apos;;&lt;br/&gt;    lanzarerrorparametro EXCEPTION;&lt;br/&gt;    proyectotxt          VARCHAR2(3) := &apos;&apos;;&lt;br/&gt;    contratotxt          VARCHAR2(8) := &apos;&apos;;&lt;br/&gt;    importefechadv       VARCHAR2(9);        --importeFechaVigenciaVerificador&lt;br/&gt;    CONSTANTE_BANCO      VARCHAR2(1) := &apos;2&apos;; --Constante fijo del banco paa el calculo del digito V&lt;br/&gt;  BEGIN                                      --importeFechaVigenciaVerificador&lt;br/&gt;    --Validar que la información de entrada sea correcta&lt;br/&gt;   /* dbms_output.put_line(&apos;** Valores de entrada **&apos;);&lt;br/&gt;    dbms_output.put_line(&apos;division= &apos; || division);&lt;br/&gt;    dbms_output.put_line(&apos;proyecto = &apos; || proyecto);&lt;br/&gt;    dbms_output.put_line(&apos;contrato = &apos; || contrato);&lt;br/&gt;    dbms_output.put_line(&apos;lineaCapturaIN = &apos; || lineacapturain);&lt;br/&gt;    dbms_output.put_line(&apos;importeFechaDV = &apos; || importefechadv);&lt;br/&gt;    dbms_output.put_line(&apos;nombrebanco = &apos; || nombrebanco);&lt;br/&gt;    dbms_output.put_line(&apos;fechatransaccion = &apos; || fechatransaccion);&lt;br/&gt;    dbms_output.put_line(&apos;totalFactuado = &apos; || totalFactuado);&lt;br/&gt;    dbms_output.put_line(&apos;referencia = &apos; || referencia);*/&lt;br/&gt;    /*Que la división sean dos digitos 01 o 02, de lo contrario se regresa error&lt;br/&gt;    **101 - Error de datos de entrada : División solo puede ser 01 Renta, 02 Venta*/&lt;br/&gt;    errorparametro     := NVL(division, &apos;101&apos;);&lt;br/&gt;    IF ( errorparametro = &apos;101&apos; ) THEN&lt;br/&gt;      RAISE lanzarerrorparametro;&lt;br/&gt;    END IF;&lt;br/&gt;    -- dbms_output.put_line(&apos;lineaCapturaP= &apos; || lineacaptura);&lt;br/&gt;    /*Proyecto sea de 3 digitos, de lo contrario se regresa error&lt;br/&gt;    **102 - Error de datos de entrada : Digitos del Proyecto no es valido, deben ser 3 digitos*/&lt;br/&gt;    errorparametro     := NVL(proyecto, &apos;102&apos;);&lt;br/&gt;    IF ( errorparametro = &apos;102&apos; ) THEN&lt;br/&gt;      RAISE lanzarerrorparametro;&lt;br/&gt;    ELSE --Convertir proyecto a cadena 3 digitos&lt;br/&gt;      proyectotxt := lpad(proyecto, 3, &apos;0&apos;);&lt;br/&gt;    END IF;&lt;br/&gt;    /*Exista un contrato, de lo contrario se regresa error&lt;br/&gt;    **103 - Error de datos de entrada : Numero de contrato no es valido, deben ser diferente de nulo*/&lt;br/&gt;    errorparametro     := NVL(contrato, &apos;103&apos;);&lt;br/&gt;    IF ( errorparametro = &apos;103&apos; ) THEN&lt;br/&gt;      RAISE lanzarerrorparametro;&lt;br/&gt;    ELSE --Convertir contrato a cadena 8 digitos&lt;br/&gt;      contratotxt := lpad(contrato, 8, &apos;0&apos;);&lt;br/&gt;    END IF;&lt;br/&gt;    -- dbms_output.put_line(&apos;contratoTxt= &apos; || contratotxt);&lt;br/&gt;    /*Exista línea de captura, de lo contrario se regresa error&lt;br/&gt;    **104 - Error de datos de entrada : Numero de contrato no es valido, deben ser diferente de nulo*/&lt;br/&gt;    errorparametro     := NVL(lineacapturain, &apos;104&apos;);&lt;br/&gt;    IF ( errorparametro = &apos;104&apos; ) THEN&lt;br/&gt;      RAISE lanzarerrorparametro;&lt;br/&gt;    END IF;&lt;br/&gt;    -- dbms_output.put_line(&apos;lineaCapturaL= &apos; || lineacaptura);&lt;br/&gt;    /*importeFechaDV sea de 8 digitos, de lo contrario se regresa error&lt;br/&gt;    **105 - Error de datos de entrada : el importe, fecha de vigencia y digito verificador no es valido, deben ser de 8 digitos*/&lt;br/&gt;    errorparametro     := NVL(nombrebanco, &apos;105&apos;);&lt;br/&gt;    IF ( errorparametro = &apos;105&apos; ) THEN&lt;br/&gt;      RAISE lanzarerrorparametro;&lt;br/&gt;    ELSE&lt;br/&gt;      errorparametro     := NVL(fechatransaccion, &apos;105&apos;);&lt;br/&gt;      IF ( errorparametro = &apos;105&apos; ) THEN&lt;br/&gt;        RAISE lanzarerrorparametro;&lt;br/&gt;      END IF;&lt;br/&gt;    END IF;&lt;br/&gt;    -- constante del banco&lt;br/&gt;      -- to_date (fechatransaccion)&lt;br/&gt;    importefechadv := xxfr_digitoverificador(nombrebanco, fechatransaccion,CONSTANTE_BANCO, nvl(totalFactuado,&apos;&apos;), NVL(referencia,&apos;&apos;));&lt;br/&gt;    -- dbms_output.put_line(&apos;lineaCapturaI= &apos; || lineacaptura);&lt;br/&gt;    /* Procesar parametros y formar codigo de la LC&lt;br/&gt;    */&lt;br/&gt;    lineacaptura := ( lpad(division,2,&apos;0&apos;) || lpad(proyectotxt,3,&apos;0&apos;) || contratotxt || lineacapturain || importefechadv );&lt;br/&gt;    -- dbms_output.put_line(&apos;lineaCaptura = &apos; || lineacaptura);&lt;br/&gt;    RETURN lineacaptura;&lt;br/&gt;  EXCEPTION -- exception handlers begin&lt;br/&gt;  WHEN lanzarerrorparametro THEN&lt;br/&gt;    RETURN errorparametro;&lt;br/&gt;  END xxfr_generarlc;&lt;br/&gt;/*&lt;br/&gt;Función que permite procesar el lote de facturas definidas por un IDBATCH, y lograr Generar la línea de captura&lt;br/&gt;aplicando las reglas especificadas en los requerimientos funcionales&lt;br/&gt;*/&lt;br/&gt;  FUNCTION xxfr_procesar_batch(&lt;br/&gt;      idParBatch IN VARCHAR2 )&lt;br/&gt;    -- Lanzar actualización del estatus a las&lt;br/&gt;    RETURN VARCHAR2&lt;br/&gt;  AS&lt;br/&gt;    errorparametro       VARCHAR2(30) := &apos;&apos;;&lt;br/&gt;    lanzarerrorparametro EXCEPTION;&lt;br/&gt;    proceso              VARCHAR2(3) := &apos;100&apos;; --El valor 100 corresponde a un error de infraestructura siempre y cuando el proceso genere una excepción no manejada&lt;br/&gt;    idValido number :=  0;&lt;br/&gt;    idEstatdoBatch number :=  0;&lt;br/&gt;    numLCVencidas NUMBER := 0;&lt;br/&gt;    contrato number:=0;&lt;br/&gt;    grupo VARCHAR2(30):=&apos;&apos;;&lt;br/&gt;    division VARCHAR2(30):=&apos;&apos;;&lt;br/&gt;    proyecto VARCHAR2(30):=&apos;&apos;;&lt;br/&gt;  BEGIN&lt;br/&gt;    --dbms_output.put_line(&apos; Inicia funcion XXFR_PROCESAR_BATCH Valores de entrada &apos;);&lt;br/&gt;    select count(*) INTO idValido FROM XXFR_CABECERA_FACTURA &lt;br/&gt;    WHERE idbatch = idParBatch;&lt;br/&gt;&lt;br/&gt;    select CONTRACTNUMBER INTO contrato FROM XXFR_CABECERA_FACTURA &lt;br/&gt;    WHERE idbatch = idParBatch and rownum =1;&lt;br/&gt;  &lt;br/&gt;    &lt;br/&gt;    --dbms_output.put_line(&apos; idValido &apos;||idValido);&lt;br/&gt;    if idValido = 0 then &lt;br/&gt;      errorparametro :=  &apos;107&apos;;&lt;br/&gt;      insert into XXFR_ESTADO_BATCH (IDBATCH ,ESTADO ,INICIOPROCESO) values (idParBatch, &apos;ERROR-107&apos;, current_date);&lt;br/&gt;      RAISE lanzarerrorparametro;&lt;br/&gt;    end if;&lt;br/&gt;    -- Insertar la bitácora del proceso de generación de LC&lt;br/&gt;     insert into XXFR_ESTADO_BATCH ( IDBATCH ,ESTADO ,INICIOPROCESO) values (idParBatch, &apos;PROCESO&apos;, current_date);&lt;br/&gt;    select max(IDESTADOBATCH) into idEstatdoBatch from XXFR_ESTADO_BATCH where idbatch = idParBatch;&lt;br/&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;br/&gt;    /*&lt;br/&gt;&lt;br/&gt;    Verificar si existen para el idBatch lineas de captura vencidas    &lt;br/&gt;    &lt;br/&gt;          Procesar lineas de captura que esten VENCIDAS, generar nueva LC&lt;br/&gt;        --1.Clonar lineas de captura vencidadas xxfr_linea_captura&lt;br/&gt;        --2.Recalcular la linea de captura clonada con su correspondiente ID y fecha de vigencia&lt;br/&gt;        *********************&lt;br/&gt;        --3.Actualizar id linea de captura en cabecera a nulo y idBatch al enviado&lt;br/&gt;        --4.Actualizar las linea de captura Vs idFacPimavera a 0:Inactivas e insertar nuevas... en LineaCaptura_Factura&lt;br/&gt;        --5.Actualizar en linea_Captura el Estatus de Activo a Inactivo.(Eliminar el campo)&lt;br/&gt;    &lt;br/&gt;    */&lt;br/&gt;    select count(*) into numLCVencidas from XXFR_LINEA_CAPTURA where &lt;br/&gt;        IDLINEACAPTURA in&lt;br/&gt;        (select IDLINEACAPTURA&lt;br/&gt;             from XXFRV_LC_Cancelar where CONTRACTNUMBER in (select CONTRACTNUMBER from XXFR_CABECERA_FACTURA where idBatch = idParBatch)) ;&lt;br/&gt;    if numLCVencidas&gt;0 then &lt;br/&gt;        errorparametro := procesarLC_Vencidadas(idParBatch,contrato, grupo, division, proyecto);&lt;br/&gt;        if (errorparametro != &apos;&apos;) then -- Si hay algun error en el proceso de LC vencidas, lanzar roll back y manejo de exception&lt;br/&gt;          RAISE lanzarerrorparametro;&lt;br/&gt;        end if;&lt;br/&gt;    end if;&lt;br/&gt;    &lt;br/&gt;    /*&lt;br/&gt;      Iniciar proceso de Lineas de captura.&lt;br/&gt;    */&lt;br/&gt;    &lt;br/&gt;    errorparametro := &apos;100&apos;;&lt;br/&gt;    INSERT&lt;br/&gt;    INTO XXFR_LINEA_CAPTURA&lt;br/&gt;      (&lt;br/&gt;        LINEACAPTURA,&lt;br/&gt;        FECHACREACION,&lt;br/&gt;        ESTATUSLC,&lt;br/&gt;        BANCO,&lt;br/&gt;        DIVISION,&lt;br/&gt;        CENTROCOSTOSPROYECTO,&lt;br/&gt;        TIPOCOBRANZA,&lt;br/&gt;        MONTOLINEACAPTURA,&lt;br/&gt;        FECHAVIGENCIA,&lt;br/&gt;        LINEACAPTURAREF,&lt;br/&gt;        REFERENCIA&lt;br/&gt;      )&lt;br/&gt;    SELECT distinct xxfr_ingresos_lc.xxfr_generarlc(flc.divisiontype, flc.PROJECTID, flc.contractnumber, &apos;CODSEQING&apos;,flc.BANKNAME, to_char(flc.CREATIONDATETRX), flc.TOTALAMOUNT, flc.REFERENCENUMBER) LC,&lt;br/&gt;      CURRENT_DATE,&lt;br/&gt;      &apos;ACTIVO&apos;,&lt;br/&gt;      flc.BANKNAME,&lt;br/&gt;      flc.divisiontype,&lt;br/&gt;      flc.PROJECTID,&lt;br/&gt;      flc.tipocobranza,&lt;br/&gt;      flc.TOTALAMOUNT,&lt;br/&gt;      XXFRP_FECHA.FECHA_FIN_VIGENCIA(current_date , PAYMENTTERMDAYS) FECHAVIGENCIA,&lt;br/&gt;      to_char(flc.CREATIONDATETRX)|| &apos;|&apos;|| flc.TOTALAMOUNT,&lt;br/&gt;      flc.REFERENCENUMBER&lt;br/&gt;    FROM XXFRV_FacturasParaLC flc&lt;br/&gt;    WHERE flc.idbatch = idParBatch;&lt;br/&gt;    &lt;br/&gt;    /** Actualizar las LINEA DE CAPTURA CON IDSeq **/&lt;br/&gt;    UPDATE XXFR_LINEA_CAPTURA&lt;br/&gt;    SET lineaCaptura = REPLACE(lineaCaptura,&apos;CODSEQING&apos;,lpad(idLineaCaptura,9,&apos;0&apos;));&lt;br/&gt;    &lt;br/&gt;    &lt;br/&gt;    /*Actuaizar las lineas de captura sobre las facturas del batch*/&lt;br/&gt;    insert into XXFR_LINEA_CAPTURA_FACTURA ( idfacturaprimavera, idlineacaptura, CS_ESTATUS )&lt;br/&gt;    select  flc.IDFACTURAPRIMAVERA, lc.idlineacaptura, 1&lt;br/&gt;        from xxfrv_lc_factura flc left outer join xxfr_linea_captura lc &lt;br/&gt;          on (lineacaptura like  substr(lc_calculada,1,13)||&apos;_________&apos;||substr(lc_calculada,23,8))&lt;br/&gt;          where flc.IDBATCH = idParBatch;&lt;br/&gt;          &lt;br/&gt;    &lt;br/&gt;    /* Actualizar los Identificadores de lineas de captura VIGENTES para cada una de las facturas Primavera&lt;br/&gt;    */&lt;br/&gt;    UPDATE XXFR_CABECERA_FACTURA fac&lt;br/&gt;    SET fac.idlineacaptura =&lt;br/&gt;      (SELECT max (flc.idlineacaptura)&lt;br/&gt;      FROM XXFR_LINEA_CAPTURA_FACTURA flc&lt;br/&gt;      WHERE fac.idfacturaprimavera = flc.idfacturaprimavera and flc.cs_estatus = 1&lt;br/&gt;      )&lt;br/&gt;    WHERE fac.idlineacaptura IS NULL&lt;br/&gt;    AND fac.idbatch           = idParBatch;&lt;br/&gt;    -- Todo está okas hasta aquí, se asigna exitoso el proceso&lt;br/&gt;    update XXFR_ESTADO_BATCH Set ESTADO =&apos;EXITOSO&apos; , finproceso = current_date where idestadobatch = idEstatdoBatch ;&lt;br/&gt;    &lt;br/&gt;    proceso := &apos;0&apos;;&lt;br/&gt;    --6.Commit&lt;br/&gt;    COMMIT;&lt;br/&gt;    RETURN proceso; -- Exitoso&lt;br/&gt;  EXCEPTION         -- exception handlers begin&lt;br/&gt;  WHEN lanzarerrorparametro THEN &lt;br/&gt;   -- Deshacer todos los cambios del procesamiento del Batch&lt;br/&gt;    rollback;&lt;br/&gt;    --Insertar estatus del proceso&lt;br/&gt;      insert into XXFR_ESTADO_BATCH (IDBATCH ,ESTADO ,INICIOPROCESO, finproceso) &lt;br/&gt;              values (idParBatch, &apos;ERROR-&apos;||errorparametro, current_date, current_date);&lt;br/&gt;    commit;&lt;br/&gt;    RETURN errorparametro;&lt;br/&gt;  END xxfr_procesar_batch;&lt;br/&gt;  &lt;br/&gt;  function procesarLC_Vencidadas (pIdBatch IN VARCHAR2, contrato in VARCHAR2, grupo in VARCHAR2, division in VARCHAR2, proyecto in VARCHAR2) return varchar2&lt;br/&gt;  as&lt;br/&gt;    errorparametro       VARCHAR2(30) := &apos;&apos;;&lt;br/&gt;    proceso VARCHAR2(3):= &apos;&apos;;&lt;br/&gt;    lanzarerrorparametro EXCEPTION;&lt;br/&gt;  Begin&lt;br/&gt;             &lt;br/&gt;             --1.Registrar el historico de la relaci[on entre factura - Batch, ya que se actualizara por el solicitado a ejecutar&lt;br/&gt;       insert into XXFRT_HISTORICO_FAC_BATCH (IDFACTURA,IDBATCH, IDBATCHACTUAL)  &lt;br/&gt;       select IDFACTURAPRIMAVERA, IDBATCH, pIdBatch&lt;br/&gt;             from XXFRV_LC_Cancelar where CONTRACTNUMBER in (select CONTRACTNUMBER from XXFR_CABECERA_FACTURA where idBatch = pIdBatch);&lt;br/&gt;             &lt;br/&gt;             &lt;br/&gt;        --2.Actualizar las linea de captura Vs idFacPimavera a 0:Inactivas e insertar nuevas... en LineaCaptura_Factura&lt;br/&gt;        update XXFR_LINEA_CAPTURA_FACTURA lcf set CS_ESTATUS = 0, lcf.FEC_VENCIDA= current_date &lt;br/&gt;        where CS_ESTATUS = 1 and lcf.IDLINEACAPTURA in&lt;br/&gt;        (select IDLINEACAPTURA&lt;br/&gt;             from XXFRV_LC_Cancelar where CONTRACTNUMBER in (select CONTRACTNUMBER from XXFR_CABECERA_FACTURA where idBatch = pIdBatch));&lt;br/&gt;            &lt;br/&gt;            -- 3. Actualizo estatus de lineasCaptura&lt;br/&gt;            update XXFR_LINEA_CAPTURA &lt;br/&gt;              Set ESTATUSLC = &apos;VENCIDA&apos;&lt;br/&gt;            where IDLINEACAPTURA in&lt;br/&gt;            (select IDLINEACAPTURA&lt;br/&gt;             from XXFRV_LC_Cancelar where CONTRACTNUMBER in (select CONTRACTNUMBER from XXFR_CABECERA_FACTURA where idBatch = pIdBatch));&lt;br/&gt;             &lt;br/&gt;       -- 3. Actualizar id linea de captura en cabecera&lt;br/&gt;        update xxfr_cabecera_factura fac &lt;br/&gt;         Set fac.IDBATCH = pIdBatch, fac.IDLINEACAPTURA = null&lt;br/&gt;            where fac.IDFACTURAPRIMAVERA in&lt;br/&gt;            (select hfb.IDFACTURA&lt;br/&gt;             from XXFRT_HISTORICO_FAC_BATCH hfb where  hfb.IDBATCHACTUAL =  pIdBatch);&lt;br/&gt;             &lt;br/&gt;&lt;br/&gt;        &lt;br/&gt;&lt;br/&gt;            &lt;br/&gt;      RETURN proceso; -- Exitoso&lt;br/&gt;  EXCEPTION         -- exception handlers begin&lt;br/&gt;  WHEN lanzarerrorparametro THEN   &lt;br/&gt;    RETURN &apos;108&apos;;&lt;br/&gt;  END procesarLC_Vencidadas;&lt;br/&gt;  &lt;br/&gt;/*&lt;br/&gt;Función que permite recuperar el digito verificador considerando la cuenta bancaría y la fecha de registro de la factura&lt;br/&gt;En caso de error regresará un código de 4 caracteres, ver referencia a las descriciones de errores en documento de&lt;br/&gt;--Catalogo de errores.&lt;br/&gt;*/&lt;br/&gt;  FUNCTION xxfr_digitoverificador(&lt;br/&gt;      nombrebanco   IN VARCHAR2,&lt;br/&gt;      fechabase     IN VARCHAR2 ,&lt;br/&gt;      constante     IN VARCHAR2,&lt;br/&gt;      totalFactuado IN VARCHAR2,&lt;br/&gt;      referencia IN VARCHAR2&lt;br/&gt;      )&lt;br/&gt;    RETURN VARCHAR2&lt;br/&gt;  AS&lt;br/&gt;    errorparametro       VARCHAR2(30) := &apos;&apos;;&lt;br/&gt;    digitoverificador    VARCHAR2(8)  := &apos;&apos;;&lt;br/&gt;    anhiobase            NUMBER       := 0;&lt;br/&gt;    mesbase              NUMBER       := 0;&lt;br/&gt;    diabase              NUMBER       := 0;&lt;br/&gt;    fechaBaseTD              date;&lt;br/&gt;    &lt;br/&gt;    fechacondensada      NUMBER;&lt;br/&gt;    importeCondensada    NUMBER;&lt;br/&gt;    lanzarerrorparametro EXCEPTION;&lt;br/&gt;  BEGIN&lt;br/&gt;    -- dbms_output.put_line(&apos;nombreBanco = &apos; || nombrebanco);&lt;br/&gt;    -- dbms_output.put_line(&apos;fechaBase = &apos; || fechabase);&lt;br/&gt;    fechaBaseTD := to_date( fechabase, &apos;YYYY-MM-DD&apos;);&lt;br/&gt;    -- dbms_output.put_line(&apos;fechaBaseTD = &apos; || fechaBaseTD);&lt;br/&gt;    SELECT EXTRACT(YEAR FROM fechaBaseTD)&lt;br/&gt;    INTO anhiobase&lt;br/&gt;    FROM dual;&lt;br/&gt;    -- dbms_output.put_line(&apos;anhioBase = &apos; || anhiobase);&lt;br/&gt;    SELECT EXTRACT(MONTH FROM fechaBaseTD)&lt;br/&gt;    INTO mesbase&lt;br/&gt;    FROM dual;&lt;br/&gt;    SELECT EXTRACT(DAY FROM fechaBaseTD) INTO diabase FROM dual;&lt;br/&gt;    /*&lt;br/&gt;    i) Al año se le resta el valor 2014&lt;br/&gt;    i) Al resultado de la resta se le multiplica por 372&lt;br/&gt;    ii) Al mes se le resta el valor 1&lt;br/&gt;    i) Al resultado de la resta se le multiplica por 31&lt;br/&gt;    iii) Al día se le resta el valor 1&lt;br/&gt;    iv) Se suman los valores resultantes (año, mes y día) y el resultado es la Nueva Fecha Condensada Base 2014&lt;br/&gt;    */&lt;br/&gt;    /* RESOLVIENDO - FECHA CONDENSADA&lt;br/&gt;    i) Al año se le resta el valor 2014BBVA o 2013BANORTE&lt;br/&gt;    i) Al resultado de la resta se le multiplica por 372*/&lt;br/&gt;    &lt;br/&gt;    CASE nombrebanco&lt;br/&gt;    WHEN descNomBancoBBVA THEN&lt;br/&gt;      anhiobase := ( anhiobase - 2014 ) * 372;&lt;br/&gt;    WHEN descNomBancoBANORTE THEN&lt;br/&gt;      anhiobase := ( anhiobase - 2013 ) * 372;&lt;br/&gt;    ELSE&lt;br/&gt;      errorparametro := &apos;ME-106&apos;; -- Error de datos : No corresponde a un banco valido&lt;br/&gt;    END CASE;&lt;br/&gt;    /*&lt;br/&gt;    ii) Al mes se le resta el valor 1&lt;br/&gt;    i) Al resultado de la resta se le multiplica por 31*/&lt;br/&gt;    mesbase := ( mesbase - 1 ) * 31;&lt;br/&gt;    /*&lt;br/&gt;    iii) Al día se le resta el valor 1*/&lt;br/&gt;    diabase := ( diabase - 1 );&lt;br/&gt;    /* dbms_output.put_line(&apos;anhioBase = &apos; || anhiobase);&lt;br/&gt;    dbms_output.put_line(&apos;mesBase = &apos; || mesbase);&lt;br/&gt;    dbms_output.put_line(&apos;diaBase = &apos; || diabase); */&lt;br/&gt;    /*&lt;br/&gt;    iv) Se suman los valores resultantes (año, mes y día) y el resultado es la Nueva Fecha Condensada Base 2014&lt;br/&gt;    */&lt;br/&gt;    fechacondensada := lpad((anhiobase + mesbase + diabase), 4, &apos;0&apos;);&lt;br/&gt;    -- dbms_output.put_line(&apos;fechaCondensada = &apos; || fechacondensada);&lt;br/&gt;    -- dbms_output.put_line(&apos;digitoVerificador = &apos; || digitoverificador);&lt;br/&gt;    /*&lt;br/&gt;    IMPOrTE CONDENSADO&lt;br/&gt;    */&lt;br/&gt;    -- Finalmente se divide po un facto base10&lt;br/&gt;    importeCondensada := calculaImpoteCondensado (totalFactuado, nombrebanco) ;&lt;br/&gt;    -- dbms_output.put_line(&apos;fechacondensada = &apos; || fechacondensada);&lt;br/&gt;    -- dbms_output.put_line(&apos;importeCondensada = &apos; || importeCondensada);&lt;br/&gt;    -- dbms_output.put_line(&apos;constante = &apos; || constante);&lt;br/&gt;    digitoverificador := codeSumDV(referencia);&lt;br/&gt;    digitoverificador := lpad(fechacondensada, 4, &apos;0&apos;) || lpad(importeCondensada, 1, &apos;0&apos;) || constante ||digitoverificador;&lt;br/&gt;    /*&lt;br/&gt;    DVs&lt;br/&gt;    */&lt;br/&gt;    -- dbms_output.put_line(&apos;digitoverificador = &apos; || digitoverificador);&lt;br/&gt;    &lt;br/&gt;    -- dbms_output.put_line(&apos;referencia = &apos; || referencia);&lt;br/&gt;    RETURN digitoverificador;&lt;br/&gt;  EXCEPTION -- exception handlers begin&lt;br/&gt;  WHEN lanzarerrorparametro THEN&lt;br/&gt;    RETURN errorparametro;&lt;br/&gt;  END xxfr_digitoverificador;&lt;br/&gt;  &lt;br/&gt;  /*&lt;br/&gt;   CodeSum&lt;br/&gt;  */&lt;br/&gt;  FUNCTION codeSumDV (referencia IN VARCHAR2) RETURN VARCHAR2 AS&lt;br/&gt;  &lt;br/&gt;  verificationCodeSum VARCHAR2(42);&lt;br/&gt;    digito    VARCHAR2(1);&lt;br/&gt;    acumula   NUMBER := 0;&lt;br/&gt;    pos       NUMBER;&lt;br/&gt;    valoPos   NUMBER;&lt;br/&gt;    residuo NUMBER;&lt;br/&gt;    &lt;br/&gt;  begin&lt;br/&gt;  &lt;br/&gt;  verificationCodeSum := &apos;&apos;;&lt;br/&gt;  &lt;br/&gt;    FOR pos IN 1..length(referencia)&lt;br/&gt;    LOOP&lt;br/&gt;      digito  := SUBSTR(referencia,pos,1);&lt;br/&gt;      &lt;br/&gt;      valoPos := TO_NUMBER(digito);&lt;br/&gt;      residuo := mod(pos, 5);&lt;br/&gt;      &lt;br/&gt;      if (residuo= 0) then&lt;br/&gt;				acumula := acumula + (valoPos * 13);&lt;br/&gt;			 elsif (residuo= 1) then&lt;br/&gt;				acumula := acumula + (valoPos * 11);&lt;br/&gt;			 elsif (residuo= 2) then&lt;br/&gt;				acumula := acumula + (valoPos * 23);&lt;br/&gt;			 elsif (residuo= 3) then&lt;br/&gt;				acumula := acumula + (valoPos * 19);&lt;br/&gt;			 else &lt;br/&gt;				acumula := acumula + (valoPos * 17);&lt;br/&gt;			end if;&lt;br/&gt;      -- dbms_output.put_line(&apos;digito = &apos; || digito||&apos;,residuo = &apos; || residuo||&apos;,acumula = &apos; || acumula);&lt;br/&gt;      &lt;br/&gt;    END LOOP;&lt;br/&gt;    verificationCodeSum := lpad((mod(acumula , 97)) + 1,2,&apos;0&apos;);&lt;br/&gt;		&lt;br/&gt;    RETURN verificationCodeSum;&lt;br/&gt;  end codeSumDV;&lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;  /*&lt;br/&gt;  Calcula el numero condesado de cantidad&lt;br/&gt;  */&lt;br/&gt;  &lt;br/&gt;  FUNCTION numCondensado(&lt;br/&gt;      numPocess IN NUMBER)&lt;br/&gt;    RETURN NUMBER&lt;br/&gt;  AS&lt;br/&gt;    numCadena VARCHAR2(11);&lt;br/&gt;    digito    VARCHAR2(1);&lt;br/&gt;    acumula   NUMBER := 0;&lt;br/&gt;    pos       NUMBER;&lt;br/&gt;    valoPos   NUMBER;&lt;br/&gt;  BEGIN&lt;br/&gt;    numCadena:= numPocess||&apos;&apos;;&lt;br/&gt;    FOR pos IN 1..length(numCadena)&lt;br/&gt;    LOOP&lt;br/&gt;      digito  := SUBSTR(numCadena,pos,1);&lt;br/&gt;      valoPos := TO_NUMBER(digito);&lt;br/&gt;      acumula := acumula + valoPos;&lt;br/&gt;    END LOOP;&lt;br/&gt;    RETURN acumula;&lt;br/&gt;  END numCondensado;&lt;br/&gt;/*&lt;br/&gt;Calcula los calculaImpoteCondensado&lt;br/&gt;*/&lt;br/&gt;  FUNCTION calculaImpoteCondensado(&lt;br/&gt;      totalFactuado IN VARCHAR2,&lt;br/&gt;      nombrebanco   IN VARCHAR2)&lt;br/&gt;    RETURN NUMBER&lt;br/&gt;  AS&lt;br/&gt;    ciclo             NUMBER := 0;&lt;br/&gt;    residuo           NUMBER := 0;&lt;br/&gt;    multiplicado      NUMBER := 0;&lt;br/&gt;    tamano            NUMBER := 0;&lt;br/&gt;    fechacondensada   NUMBER;&lt;br/&gt;    importeCondensada NUMBER;&lt;br/&gt;    temporal          VARCHAR2(16);&lt;br/&gt;    lanzarerrorparametro    EXCEPTION;&lt;br/&gt;    errorparametro    VARCHAR2(16);&lt;br/&gt;  BEGIN&lt;br/&gt;    -- dbms_output.put_line(&apos;nombrebanco = &apos; || nombrebanco);&lt;br/&gt;    importeCondensada := 0;&lt;br/&gt;    tamano            := LENGTH (totalFactuado);&lt;br/&gt;    -- dbms_output.put_line(&apos; totalFactuado = &apos; || totalFactuado);&lt;br/&gt;    FOR ciclo IN 0..12&lt;br/&gt;    LOOP&lt;br/&gt;      temporal       := SUBSTR(totalFactuado,ciclo+1,1);&lt;br/&gt;      residuo        := MOD(ciclo, 3);&lt;br/&gt;      &lt;br/&gt;      IF residuo      = 0 THEN&lt;br/&gt;        multiplicado := 7;&lt;br/&gt;      elsif residuo   = 1 THEN&lt;br/&gt;        multiplicado := 1;&lt;br/&gt;      ELSE&lt;br/&gt;        multiplicado := 3;&lt;br/&gt;      END IF;&lt;br/&gt;      &lt;br/&gt;      -- dbms_output.put_line(&apos;*** ciclo:&apos;||ciclo||&apos;,temporal = &apos; || temporal || &apos;, residuo: &apos;||residuo);&lt;br/&gt;      -- dbms_output.put_line(&apos;multiplicando por = &apos; ||multiplicado);&lt;br/&gt;      &lt;br/&gt;      CASE nombrebanco&lt;br/&gt;      WHEN descNomBancoBBVA THEN&lt;br/&gt;        importeCondensada := importeCondensada + numCondensado((temporal * multiplicado));&lt;br/&gt;      WHEN descNomBancoBANORTE THEN&lt;br/&gt;        importeCondensada := importeCondensada + ((temporal * multiplicado));&lt;br/&gt;      ELSE&lt;br/&gt;        errorparametro := &apos;ME-106&apos;; -- Error de datos : No corresponde a un banco valido&lt;br/&gt;        RAISE lanzarerrorparametro;&lt;br/&gt;      END CASE;&lt;br/&gt;      importeCondensada :=  mod (importeCondensada , 10);&lt;br/&gt;      --  dbms_output.put_line(&apos; importeCondensada = &apos; || importeCondensada);&lt;br/&gt;    END LOOP;&lt;br/&gt;    -- dbms_output.put_line(&apos; importeCondensada = &apos; || importeCondensada);&lt;br/&gt;    RETURN importeCondensada;&lt;br/&gt;  EXCEPTION&lt;br/&gt;  WHEN lanzarerrorparametro THEN&lt;br/&gt;    RETURN errorparametro;&lt;br/&gt;  END calculaImpoteCondensado;&lt;br/&gt;  &lt;br/&gt;  /*&lt;br/&gt;  Busca el total de la linea&lt;br/&gt;  */&lt;br/&gt;  function totalLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2,&lt;br/&gt;   pProjectID  IN VARCHAR2&lt;br/&gt;  ) RETURN VARCHAR2 as&lt;br/&gt;  &lt;br/&gt;  total            VARCHAR2(13) := &apos;&apos;;&lt;br/&gt;  lanzarerrorparametro Exception;&lt;br/&gt;  begin&lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;    Select sum (nvl (TOTALAMOUNT,0)) into total from XXFRV_FACTURASPARALC&lt;br/&gt;    WHERE rownum = 1 and  tipocobranza                    = &apos;LINEA CAPTURA&apos;&lt;br/&gt;    and IdBatch =  pIdBatch &lt;br/&gt;        and contractnumber  = pContractnumber&lt;br/&gt;    and divisiontype   =  pDivisiontype&lt;br/&gt;    and grouptype   =  pGrouptype&lt;br/&gt;    and projectId   =  pProjectID&lt;br/&gt;    group by idbatch,contractnumber,grouptype&lt;br/&gt;    ;&lt;br/&gt;    &lt;br/&gt;    &lt;br/&gt;     total := lpad((total), 13, &apos;0&apos; );&lt;br/&gt;    &lt;br/&gt;          RETURN  total;&lt;br/&gt;   EXCEPTION&lt;br/&gt;       WHEN NO_DATA_FOUND THEN&lt;br/&gt;    RETURN lpad (&apos;0&apos;,13,&apos;0&apos;);&lt;br/&gt;  end totalLC;&lt;br/&gt;&lt;br/&gt;/*&lt;br/&gt;  Busca el total de la linea&lt;br/&gt;  */&lt;br/&gt;  function fechaLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2,&lt;br/&gt;   pProjectID  IN VARCHAR2&lt;br/&gt;  ) RETURN VARCHAR2 as&lt;br/&gt;  &lt;br/&gt;  fechaTX            VARCHAR2(13) := &apos;&apos;;&lt;br/&gt;  lanzarerrorparametro Exception;&lt;br/&gt;  begin&lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;    Select min (nvl (CREATIONDATETRX,0)) into fechaTX from XXFRV_FACTURASPARALC&lt;br/&gt;    WHERE rownum = 1 and  tipocobranza                    = &apos;LINEA CAPTURA&apos;&lt;br/&gt;    and IdBatch =  pIdBatch &lt;br/&gt;        and contractnumber  = pContractnumber&lt;br/&gt;    and divisiontype   =  pDivisiontype&lt;br/&gt;    and grouptype   =  pGrouptype&lt;br/&gt;    and projectId   =  pProjectID&lt;br/&gt;    group by idbatch,contractnumber,grouptype&lt;br/&gt;    ;&lt;br/&gt;    &lt;br/&gt;          RETURN  fechaTX;&lt;br/&gt;   EXCEPTION&lt;br/&gt;       WHEN NO_DATA_FOUND THEN&lt;br/&gt;    RETURN &apos;2014-01-01&apos;;&lt;br/&gt;  end fechaLC;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/*&lt;br/&gt;  Busca la referencia de la linea&lt;br/&gt;  */&lt;br/&gt;  function referenciaLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2,&lt;br/&gt;   pProjectID  IN VARCHAR2&lt;br/&gt;  ) RETURN VARCHAR2 as&lt;br/&gt;  &lt;br/&gt;  referenceTX            VARCHAR2(16) := &apos;&apos;;&lt;br/&gt;  lanzarerrorparametro Exception;&lt;br/&gt;  begin&lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;    Select min (nvl (REFERENCENUMBER,0)) into referenceTX from XXFRV_FACTURASPARALC&lt;br/&gt;    WHERE rownum = 1 and  tipocobranza                    = &apos;LINEA CAPTURA&apos;&lt;br/&gt;    and IdBatch =  pIdBatch &lt;br/&gt;        and contractnumber  = pContractnumber&lt;br/&gt;    and divisiontype   =  pDivisiontype&lt;br/&gt;    and grouptype   =  pGrouptype&lt;br/&gt;    and projectId   =  pProjectID&lt;br/&gt;    group by idbatch,contractnumber,grouptype;&lt;br/&gt;    &lt;br/&gt;          RETURN  referenceTX;&lt;br/&gt;   EXCEPTION&lt;br/&gt;       WHEN NO_DATA_FOUND THEN&lt;br/&gt;    RETURN lpad (&apos;0&apos;,16-1,&apos;0&apos;);&lt;br/&gt;  end referenciaLC;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/*&lt;br/&gt;  Busca la proyectID de la linea&lt;br/&gt;  */&lt;br/&gt;  function proyectoIDLC(pIdBatch IN VARCHAR2,&lt;br/&gt;   pContractnumber  IN VARCHAR2,&lt;br/&gt;   pDivisiontype  IN VARCHAR2,&lt;br/&gt;   pGrouptype  IN VARCHAR2&lt;br/&gt;  ) RETURN VARCHAR2 as&lt;br/&gt;  &lt;br/&gt;  proyectoIDTX            VARCHAR2(16) := &apos;&apos;;&lt;br/&gt;  lanzarerrorparametro Exception;&lt;br/&gt;  begin&lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;    Select min (nvl (projectid,0)) into proyectoIDTX from XXFRV_FACTURASPARALC&lt;br/&gt;    WHERE rownum = 1 and  tipocobranza                    = &apos;LINEA CAPTURA&apos;&lt;br/&gt;    and IdBatch =  pIdBatch &lt;br/&gt;        and contractnumber  = pContractnumber&lt;br/&gt;    and divisiontype   =  pDivisiontype&lt;br/&gt;    and grouptype   =  pGrouptype&lt;br/&gt;    group by idbatch,contractnumber,grouptype;&lt;br/&gt;    &lt;br/&gt;          RETURN  lpad (proyectoIDTX,3,&apos;0&apos;);&lt;br/&gt;   EXCEPTION&lt;br/&gt;       WHEN NO_DATA_FOUND THEN&lt;br/&gt;    RETURN lpad (&apos;0&apos;,3,&apos;0&apos;);&lt;br/&gt;  end proyectoIDLC;&lt;br/&gt;&lt;br/&gt;  &lt;br/&gt;END xxfr_ingresos_lc;</source>
</body>
</PackageOracle>